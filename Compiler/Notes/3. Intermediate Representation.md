# Intermediate Representation

[TOC]

## Why we need IR

1. 实践过程中, 不断推出新的语言, 指令集, 若为每对语言, 指令集都设计一个编译器, 会导致开发成本激增
    eg: 四个语言, 三个指令集
    - without IR: $4 * front ends + 4 \times 3 * optimizers + 4\times 3 *code generators$ 
    - with IR: $4 *front ends + 1 *optimizer + 3* code generators$
2. 前后端独立. 为新机器构建编译器, 只需要设计从中间代码到新的目标机器码的编译器
3. 中间代码优化与源语言和目标机器码均无关

## the types of IR

编译器任何完整的中间输出都是中间代码表示形式, 常见类型有
* 后缀表示
* 语法树或有向无环图(Directed Acyclic Graph, DAG)
    * DAG 和语法树类似, 但一个节点可能有多个父节点
* 三地址码(Three-Address Code, TAC)--LLVM IR 的类型
    最多一个算符, 最多三个计算分量, 每个分量对应一个地址, 因此三地址.
    TAC 是 语法树或 DAG 的一种线性表示
* 静态单赋值形式(SSA)
    和 TAC 的主要区别:
    * 所有赋值指令都是对不同名字的变量的赋值, 即赋值式左侧不能有相同名字的变量
    * 同一个变量在不同控制流路径上都被定值

## Some Concepts

### Basic Block

* 连续的三地址指令序列, 控制流从基本块的开始进入, 并从它的末尾离开, 中间没有停止或分支的可能
* 基本块划分算法
    1. 确定各个基本块的第一条指令, 即首指令(leader)
        * 指令序列的第一条三地址指令是一个首指令
        * 任意跳转指令的目标指令是一个首指令
        * 紧跟一个转移指令的指令是一个首指令
    2. 每个首指令对应的基本块包括了从它自己开始, 直到下一个首指令(不含)或指令序列末尾之间的所有指令

### Flow Graph

* 流图的节点是一个基本块
* 从基本块 B 到基本块 C 之间有一条边, 当且仅当 C 的第一条指令可能紧跟着 B 的最后一条指令之后执行, 判定方法如下
    * 有一个从 B 的结尾跳转到 C 的开头的跳转指令
    * 参考三地址指令序列中的顺序, C 紧跟在 B 之后, 且 B 的结尾不是无条件跳转指令
* 循环
    * 流图中的节点集合 L 是一个循环当且仅当
        1. 该集合有唯一的入口节点--不属于 L 的节点只能通过该节点到达 L 中的其他节点
        2. 任意节点都有一个到达入口节点的非空路径, 且该路径全部在 L 中
    * 不包含其他循环的循环叫做内循环