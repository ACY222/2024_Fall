# Syntax Directed Translation

Outline of Topics

[TOC]

## Outline

*   编译程序的目标: 将源程序翻译为语义等价的目标程序
*   语法制导翻译: 使用上下文无关文法引导对语言的翻译
    *   语法制导翻译的应用
        *   语义分析: 对结构上正确的源程序进行上下文有关性质的审查
    *   语法制导翻译的问题
        *   如何表示语义信息: 为 CFG 中的文法符号设置语义属性, 用来表示语法成分对应的语义信息
        *   如何计算语义属性
            *   用与文法符号所在产生式(语法规则)相关联的语义规则来计算
            *   对于给定的输入串 x, 构建 x 的语法分析树, 并用与产生式相关联的语义规则来计算分析树中各节点对应的语义属性值

## Syntax Directed Definition

*   语法制导定义
    *   基础的上下文无关文法
    *   每个文法符号有一组属性
    *   每个产生式 $A \to \alpha$ 有一组形式为 $b = f(c_1, c_2, \ldots, c_n)$ 的语义规则, 其中 $b, c_1, c_2, \ldots, c_n$ 为该产生式文法符号的属性
    *   ***综合属性(synthesized attribute)***: 如果 b 是 ***左部文法符号*** A 的属性, $c_1, \ldots, c_n$ 是产生式右部文法符号的属性或 A 的其他属性, 那么称 b 是 A 的综合属性.
    *   ***继承属性(inherited attribute)***: 如果 b 是***右部某文法符号*** X 的属性, $c_1, \ldots, c_n$ 是 A 和产生式右部文法符号的属性, 那么称 b 是 X 的继承属性.
        *   终结符只有综合属性, 属性值由词法分析给定, 无需计算
        *   分析树中 A 的综合属性只能通过 A 的子节点或 A 本身的属性计算--自底向上计算
        *   分析树中 A 的继承属性只能通过 A 的父节点或 A 本身的属性计算--自顶向下计算
*   SDD 的构造: 为产生式构造相应的语义规则
*   注释分析树
    *   定义: 节点的属性值都标注出来的分析树--后面画的属性依赖图和 SDT 均基于注释分析树
    *   注释分析树 + 综合属性计算: 因为各节点综合属性的计算需要自底向上完成, 故可以和 LR 分析器一起自然地完成
    *   但综合属性有时并不够用, 因此我们引入继承属性
    *   语义规则建立了语义属性之间的依赖关系, 在对语法分析树节点的一个属性求值之前, 必须先求出这个属性值所依赖的所有属性值. 为了实现这个目标, 我们引入了属性依赖图
*   属性依赖图
    *   依赖图(dependency graph)是一个描述了分析树节点属性间依赖关系的有向图
        *   属性值为点(vertex): 分析树中每个节点 X 的各个属性都对应着依赖图中的一个节点
        *   属性依赖关系为边(edge): 如果属性 X.a 依赖于属性 Y.b, 则依赖图中有一条从 Y.b 对应的节点指向 X.a 对应的节点的有向边
    *   属性的计算顺序
        *   可行的求值顺序是满足下列条件的节点序列$N_1, N_2, \ldots, N_k$
            *   如果依赖图中有一条从节点 $N_i$ 指向节点 $N_j$ 的边, 那么在节点序列中 $N_i$ 排在 $N_j$ 前面
            *   该排序成为这个图的***拓扑排序(topological sort)***
            *   当有向图中出现环时, 说明 SDD 的属性之间存在循环依赖关系, 此时有向图的拓扑排序不存在. 所以我们需要使用依赖图中不存在有向环的特定类型的 SDD

### Synthesized-SDD(S属性的定义)

*   定义: 仅使用综合属性的语法制导定义
    *   S-SDD 可以按照语法分析树节点的任何自底向上顺序来计算它的各个属性值
    *   上述过程可以在自底向上的语法分析过程中实现. 也可以在自顶向下的语法分析过程中的回退操作中计算

### Left-SDD(L属性的定义)

*   直观含义: 在一个产生式所关联的各属性之间, 依赖图的边可以从左到右, 但不能从右到左
*   定义: 任意产生式 $A \to X_1, X_2, \ldots, X_n$, 其右部符号 $X_i(1 \leq i \leq n)$ 的继承属性仅依赖于下列属性
    *   A 的继承属性
    *   产生式中 $X_i$ 左边符号的属性
    *   $X_i$ 本身的属性, 但 $X_i$ 的全部属性在依赖图中不能形成环路
*   注意, S 属性是 L 属性的子集

### Application of SDD

#### Construction of Abstract Syntax Tree

*   抽象语法树(AST)
    *   简称语法树, 是 ***(语法)分析树*** 的浓缩表示: 将算符和关键字作为内部节点, 运算对象(操作数)作为叶节点
    *   语法制导翻译可以基于分析树, 也可以基于语法树
*   建立算符表达式的语法树
    *   对基本运算对象节点
        *   一个域存放运算对象的类别
        *   一个域存放其值(也可以用其他域保存其他属性或指向该属性值的指针)
    *   对算符节点
        *   一个域存放算符并作为该节点的标记
        *   其他两个域存放指向运算对象的指针
    *   操作
        *   mknode(op, left, right)
        *   mkleaf(id, entry): entry 指向标识符在符号表中的入口
        *   mkleaf(num, val)

## SDT

*   语法制导翻译方案是在产生式右部嵌入了程序片段的 CFG
*   SDT 可以看作是 SDD 的具体实施方案, 二者实际上是等价的

### S 属性定义的 SDT 实现

*   将一个 S-SDD 转换为 SDT 的方法
    *   将每个语义动作放在产生式的最后, 称为"后缀翻译方案"

#### 先建树, 后计算

*   基于分析树的语法制导翻译方案
    *   建立语法分析树
    *   将语义动作看作是虚拟节点(挂在对应节点的右侧)
    *   从左到右, 深度优先地遍历分析树, 在访问虚拟节点时执行相应的动作

#### 边分析, 边计算

*   综合属性可通过自底向上的 LR 方法来计算
*   当归约发生时执行相应的语义动作
*   具体实现: 通过扩展的 LR 语法分析栈来实现
    *   在分析栈中使用一个附加的域来存放综合属性值. 若支持多个属性, 可以在栈中存放指针/使用较大的域
    *   每个栈元素包含状态, 文法符号, 综合属性三个域(实际上, 我们在讨论过程中省去了状态, 只考虑文法符号和综合属性)
        *   也可以将分析栈看成三个平行的栈, 因为各部分入栈出栈并不完全同步
    *   语义动作将修改为对栈中文法符号属性的计算

### L 属性定义的 SDT 实现

*   将一个 L-SDD 转换为 SDT 的方法
    *   将计算一个产生式左部符号综合属性的动作放在产生式右部的最右端
    *   将计算某个非终结符 A 的继承属性的动作插入到产生式右部中紧靠在 A 的本次出现之前的位置上--根据 L-SDD 的定义, 若插入位置偏左, 所依赖的值可能还未算出; 若插入位置偏右, 后面的继承属性可能无法算出.

#### 自顶向下计算--与递归下降分析结合

* 递归下降分析器的设计
    * 为每个非终结符 A 构造一个函数
        * A 的每个继承属性对应该函数的一个形参
        * 函数的返回值是 A 的综合属性值
    * 在函数体中
        * 选择适当的 A 的产生式
        * 用局部变量保存产生式中文法符号的属性
        * 对产生式中的终结符, 读入符号并获取其综合属性(由词法分析得到)
        * 对产生式中的非终结符, 调用相应函数, 记录返回值
* 缺点: 即递归下降方法的缺点, 无法处理左递归
* eg: 产生式 $R \to +TR \;|\; \epsilon$ 的递归下降分析过程
    ```C
    void R(){
        if(lookahead == '+'){
            match('+');
            T();
            R();
        }
        else{
            \\ do nothing
        }
    }
    ```
    ```C
    syntaxTreeNode* R(syntaxTreeNode *i){   // 来自上面左部 T 的继承属性
        syntaxTreeNode *nptr, *i1, *s1, *s;
        char addoplexeme;
        
        if(lookahead == '+'){   // 产生式 1
            addloplexeme = lexval;
            match('x');
            nptr = T();
            i1 = mkNode(addoplexeme, i, nptr);
            s1 = R(i1);         // 将 i1 传下去作为下一个加法左部的继承属性
            s = s1;
        }
        else{
            s = i;              // 产生式 2
        }
        return s;
    }
    ```

#### 自底向上计算--与 LR 分析结合

* 考虑将带有继承属性的 L-SDD 与 LR 结合
    * 考虑产生式 $A\to BC$, 假设 $B.i = A.i$
        * 当对 B 进行归约时, 由于没有看到 C, 不能确定是否会使用该产生式, 此时推迟计算
        * 当按照 BC 归约成为 A 后, 我们仍然不能确定包含 A 的产生式, A.i 仍无法得知, 继续推迟
        * 最后退化为 "先造分析树, 后翻译" 的策略
* 解决方案: 可将产生式中嵌入的动作删除, 挪到产生式最右端
* 将 L-SDD 转为 SDT
    * 对于产生式 $A\to \alpha \{a\} \beta$, a 是语义动作(显然, a 涉及到 $\beta$ 的继承属性的运算)
        * 引入新的非终结符 M 代替 {a}, 形成 $A \to \alpha M \beta$
        * 引入新的产生式 $M\to \epsilon$
        * 修改 $a$ 得到 $a'$:
            * 将 a 需要的 A 或 $\alpha$ 中的属性作为 M 的继承属性进行复制
            * 按照 a 中的方法计算各属性, 将这些属性作为 M 的综合属性保存起来
        * 将 $\{a'\}$ 与 $M \to \epsilon$ 关联起来
        * eg: $A \to \{B.i = f(A.i)\} BC$
            * 修改后的 SDT 为
                * $A \to MBC$
                * $M \to \epsilon \{M.i = A.i, M.s = f(M.i)\}$
                * 文法和分析栈的设计保证了 A.i 在 M 下方紧邻的位置, 所以可以调用