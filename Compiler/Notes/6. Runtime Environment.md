# Runtime Environment

[TOC]

## Outline of Runtime Environment

- 运行时涉及的主要内容
    * 运行时存储空间组织管理概述
    * 活动树与栈式空间分配
    * 调用序列与返回序列
    * 非局部数据的访问
- 编译器为目标程序创建并管理一个运行时环境, 目标程序运行在该环境中.
    该环境提供以下功能
    * 对象存储位置和空间的分配
    * 访问变量的机制
    * 过程间的连接
    * 参数传递机制

## Storage Organization and Allocation

* 编译器必须为源程序中出现的一些数据对象分配运行时的存储空间
    * 静态存储分配
        * 对于在编译时就可以确定大小的数据对象, 可以在编译时就为他们分配空间, 这样的策略
        称为静态存储分配
    * 动态存储分配
        * 如果不能在编译时完全确定数据对象的大小, 就要采取动态存储分配的策略. 即在编译时
        仅产生必要的信息, 而在运行时再动态地分配存储空间
        * 栈式存储分配
            * 与过程调用有关, 涉及过程的局部变量以及过程活动记录
        * 堆式存储分配
            * 关系到部分生命周期较长的数据
    * 存储块是否必须被显式地释放
* 过程
    * 过程的调用与返回
    * 过程的执行需要: 代码段+活动记录(过程运行所需的额外信息, 如参数, 局部数据, 返回地址等)
    * 活动记录
        * 使用过程作为用户自定义动作的单元的语言, 其编译器通常以过程为单位分配存储空间
        * 过程的每次执行称为该过程的一个活动(activation)
        * 编译器为每一个活动分配一块连续存储区域, 用来管理此次执行所需的信息, 这片区域称为
        活动记录(activation record)
        * 活动记录的常见布局
            | 临时数据 | 保存表达式求值过程中产生的中间结果 |
            | :-----: | :----: | 
            | 局部数据 | |
            | 机器状态 | 本次过程调用前的机器状态, 如程序计数器的值 |
            | 访问链   | 用来访问存放于其他活动记录中的非局部数据 | 
            | 控制链   | 指向调用者的活动记录 | 
            | 返回值   | |
            | 参数     | |
* 局部存储分配
    * 基本概念
        * 作用域: 变量的作用范围        e.g. 局部变量与全局变量
        * 生存期: 变量从生成到撤销的这段时间
    * 环境和状态
        * 环境将名字映射到左值(即将 id 映射到该变量的存储位置)
        * 状态将左值映射到右值(即将变量从存储位置映射到值)
        * 赋值改变状态, 但不改变环境. 过程调用改变环境
        * 如果环境将名字 x 映射到存储单元 s, 则说 x 被绑定到 s
    * 静态概念与动态概念的对应
        |   静态概念   |   动态概念   |
        | :---------: | :--------: |
        | 过程的定义   | 过程的活动   |
        | 名字的声明   | 名字的绑定   |
        | 声明的作用域 | 绑定的生存期  |
    * 局部数据的布局
        * 字节是可编址内存的最小单位
        * 变量所需的存储空间可根据其类型而静态确定
        * 一个过程所声明的局部变量, 按这些变量声明时出现的次序, 在局部数据域中依次分配空间
        * 局部数据的地址可以用相对于活动记录中某个位置的地址来表示
        * 数据对象的存储布局还有对齐的问题
    * 程序块
        * 本身含有局部变量声明的语句
        * 可以嵌套
        * 并列程序块不会同时活跃
        * 并列程序块的变量可以重叠分配

## Stack Allocation of Space

* Outline
    * 对于支持过程的语言, 其编译器通常会用栈的形式来管理其运行时刻存储
    * 当一个过程被调用时, 该过程的活动记录被压入栈中; 当过程结束时, 记录被弹出
    * 这种安排不仅允许活跃时段不重叠的多个过程调用共享空间; 而且可以使得过程的非局部变量的
    相对地址总是固定的, 和调用序列无关

### Activation Tree

* 活动树
    * 用来描述程序运行期间控制进入和离开各个活动的情况的树
    * 树中的每个节点对应一个活动; 根节点是 main 过程的活动
    * 对于过程 p, 其子节点对应于被 p 的这次活动调用的各个过程的活动. 按照调用次序, 自左向右地
    显示; 一个子节点必须在其右兄弟节点对应的活动开始之间结束
    * 当前活跃着的过程活动可以保存在一个栈中$\to$控制栈
        * 每个活跃的活动都有一个位于控制栈中的活动记录
        * 活动树的根节点的记录位于栈底
        * 程序控制所在的活动的记录位于栈顶
        * 栈中全部活动记录的序列对应在活动树中到达当前控制所在的活动节点的路径
* 运行栈
    * 把控制栈中的信息拓广到包括过程活动所需的所有局部信息(即活动记录, activation record)

### Calling Sequence && Return Sequence

* 对运行栈的管理
    * 代码序列: 过程调用和过程返回都需要执行一些代码来管理运行栈
    * 过程调用序列: 过程调用时执行. 分配活动记录, 将信息填入它的域中, 使被调用过程开始执行
    * 过程返回序列: 被调用过程返回时执行. 恢复机器状态, 释放被调用过程活动记录, 使调用过程
    继续执行
    * 调用序列和返回序列都分成两部分, 分处于调用过程和被调用过程的活动记录中.
* 过程调用序列/返回序列和活动记录中各域的次序因实现而异, 但有一些基本原则
    * 调用者与被调用者之间交流的数据放在被调用者活动记录的开始处
        * 参数域紧邻调用者活动记录
        * 返回域在参数域之上
    * 固定长度的域放在活动记录的中间
        * 控制链, 访问链, 机器状态
    * 编译时不能确定大小的数据一般放在活动记录的末端
        * 局部动态数组, 临时数据
    * 以活动记录中间的某个位置(控制链)作为基地址
* 过程调用序列
    * 两个指针: 
        * `top_sp`, 栈顶寄存器, 指向栈顶活动记录的末端; 
        * `base_sp`, 基址寄存器, 指向栈顶活动记录中控制链所在位置
    * 过程 p 调用过程 q 的调用序列
        1. p 计算实参, 依次放入栈顶, 并在栈顶留出放返回值的空间(过程中 top_sp 改变)
        2. p 把返回地址和当前 base_sp 的值存入 q 的活动记录中, 建立 q 的控制链, 修改
        base_sp 的值
        3. q 保存寄存器的值和其他机器状态信息
        4. q 根据局部数据域和临时数据域的大小修改 top_sp 的值, 初始化局部数据并开始执行过程
    * 过程 p 调用过程 q 的返回序列
        1. q 把返回值放在指定位置
        2. q 对应调用序列的步骤 4, 修改 top_sp 的值
        3. q 恢复寄存器(包括 base_up)和机器状态, 返回 p
        4. p 根据参数个数与类型和返回值类型调整 top_sp, 然后取出返回值
    * 过程参数可变的情况
        1. 函数返回值用寄存器传递
        2. 编译器产生将实参表达式逆序计算并将结果入栈的代码
* 全局栈式存储分配
    * 栈上可变长数据
        * 数据对象的长度在编译时不能确定, 但仅为该活动使用, 放在栈上可以避免垃圾回收开销
    * 如何布局?
        * 先分配存放数组指针的单元, 对数组的访问通过指针间接实现
        * 运行时, 指针指向分配在栈顶的数组存储空间

## Access to Nonlocal Data on the Stack

### Nested Procedures?

* 过程嵌套
    * 无过程嵌套的数据访问
        * 过程体中的非局部引用可直接使用静态确定的地址(非局部数据此时就是全局数据)
        * 局部变量在栈顶的活动记录中, 可以通过 base_sp 指针来访问
        * 无需深入栈中取数据, 无需访问链
    * 有过程嵌套的数据访问
        * 如 PASCAL 中, 可以在一个过程中声明另一个过程.
        * 如果过程 A 的声明中包含了过程 B 的声明, 那么 B 可以使用在 A 中声明的变量
        * 需要建立访问链使 B 能够找到 A 的活动记录

### Data Access with Nested Procedures

* 过程嵌套
    * 例子
        ```
        sort
            readarray
            exchange
            quicksort
                partition   
        ```
    * 过程嵌套深度: 主程序为 1, 进入一个被包围的过程时加 1
    * 变量嵌套深度: 它的声明所在过程的嵌套深度作为改名字的嵌套深度
    * 过程嵌套的静态作用域在活动记录中增加访问指针形成访问链
        * 用来寻找非局部名字的存储单元
        * 假设 p 直接嵌套在 q 中, 那么 p 活动记录的访问链指针指向最靠近的 p 的活动记录
* 通过访问链访问非局部引用
    * 设过程 p 的嵌套深度为 $n_p$, 它引用嵌套深度为 $n_a$ 的变量  a
        * $n_a \leq n_p$
            * 从栈顶的活动记录开始, 追踪访问链 $n_p-n_a$ 此
            * 到达 a 的声明所在过程的活动记录
            * 访问链的追踪可用间接操作完成
* 访问链的建立
    * 设嵌套深度为 $n_x$ 的过程 x 调用嵌套深度为 $n_y$ 的过程 y
        * 若 $n_x < n_y$(外层调用内层)
            * y 肯定是在 x 中定义的, y 的访问链指向 x
        * 若 $n_x = n_y$(本层调用本层)
            * y 与 x 的访问链相同, 直接复制即可
        * 若 $n_x > n_y$(内层调用外层)
            * 过程 x 必定嵌套在某个过程 z 中, 而 z 中定义了 y
            * 从 x 的活动记录开始, 沿着访问链经过 $n_x - n_y + 1$ 步就可以找到离栈顶
            最近的 z 的活动记录, y 的访问链指向 z